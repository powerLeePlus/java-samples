# 结构型模式之---装饰者模式

![UML](UML.png)

关键点：
1. 要有公共接口，装饰类和被装饰类都要实现该接口
2. 装饰类要持有公共接口的引用
3. 为了扩展性，装饰类可以定义父类，具体子类继承该装饰父类，并完成具体装饰。
4. 真正装饰的时候，会调用被装饰类的原有方法，然后再增加相关扩展的功能。

一句话理解：在保证访问原有接口A方式不变的情况下，对接口A进行功能扩展

## 装饰器模式和代理模式的区别
- 代理模式是代理类（Proxy）和真实主题（RealSubject）都是实现了抽象主题（Subject）接口，同时代理类组合（Composite）真实主题（**真实主题由代理类new出来的**）。
- 装饰器模式是抽象装饰器（Decorator）和具体组件（ConcreteComponent）都继承了抽象组件（Component），抽象装饰器聚合（Aggregation）抽象组件，**需要调用者创建具体组件给装饰器进行装饰**。
- 因此，可以仔细想一下，为什么说代理模式是控制对象访问(由代理生成的)，装饰器是装饰对象(由调用者生成再传给装饰器的)。